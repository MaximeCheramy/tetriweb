<html>
	<head>
		<style type="text/css">
		<!--
			.bloc {
				position: absolute;
				width: 16px;
				height: 16px;
				border: 1px solid #000000;
			}
			.piece {
				position: absolute;
				width: 80px;
				height: 80px;
				//border: 1px solid #000000;
			}

			#airejeu {
				position: absolute;
				top: 20px;
				left: 20px;
				width: 240px;
				height: 440px;
				border: 2px solid #222222;
			}

			#nextpiece {
				position: absolute;
				top: 20px;
				left: 280px;
				width: 80px;
				height: 80px;
				border: 2px solid #222222;
			}

		-->
		</style>
		<script type="text/javascript">
		<!--
		var gamearea = new Array(22);
		var cur_x = 6;
		var cur_y = 0;
		var current;
		var currentobj = null;
		var currentcolor;
		var montimer;
		var piecedepose = true;
		var perdu = false;
		var next_id;
		var next_o;

		function init() {
			// init the game area : all empty.
			for (var l = 0; l < 22; l++) {
				gamearea[l] = new Array(12);
				for (var c = 0; c < 12; c++) {
					gamearea[l][c] = -1;
				}
			}

			generate_random();
			newpiece();

			montimer = window.setTimeout("step()", 1000);
		}

		function rotate(piece) {
			var npiece = new Array(4);
			for (var l = 0; l < 4; l++) {
				npiece[l] = new Array(4);
				for (var c = 0; c < 4; c++) {
					npiece[l][c] = piece[3-c][l];
				}
			}
			return npiece;
		}

		function generate_random() {
			next_id = Math.floor(Math.random() * 7);
			next_o = Math.floor(Math.random() * 4);

			nextpiece = generate_piece(next_id, next_o);
			nextpieceobj = document.getElementById("nextpiece");
			while (nextpieceobj.childNodes.length > 0) {
				nextpieceobj.removeChild(nextpieceobj.childNodes[0]);
			}
			for (var l = 0; l < 4; l++) {
				for (var c = 0; c < 4; c++) {
					if (nextpiece[l][c]) {
						bloc = document.createElement("div");
						nextpieceobj.appendChild(bloc);
						bloc.className = 'bloc';
						bloc.style.top = l * 20 + 1;
						bloc.style.left = c * 20 + 1;
						bloc.style.background = convert(next_id);
					}
				}
			}

		}

		function generate_piece(id, orientation) {
			var piece = new Array(4);

			switch (id) {
				case 0:
					piece[0] = new Array(false, false, false, false);
					piece[1] = new Array(true, true, true, true);
					piece[2] = new Array(false, false, false, false);
					piece[3] = new Array(false, false, false, false);
					break;
				case 1:
					piece[0] = new Array(false, false, false, false);
					piece[1] = new Array(false, true, true, false);
					piece[2] = new Array(false, true, true, false);
					piece[3] = new Array(false, false, false, false);
					break;
				case 2:
					piece[0] = new Array(false, true, false, false);
					piece[1] = new Array(false, true, false, false);
					piece[2] = new Array(true, true, false, false);
					piece[3] = new Array(false, false, false, false);
					break;
				case 3:
					piece[0] = new Array(true, false, false, false);
					piece[1] = new Array(true, false, false, false);
					piece[2] = new Array(true, true, false, false);
					piece[3] = new Array(false, false, false, false);
					break;
				case 4:
					piece[0] = new Array(false, false, false, false);
					piece[1] = new Array(true, true, false, false);
					piece[2] = new Array(false, true, true, false);
					piece[3] = new Array(false, false, false, false);
					break;
				case 5:
					piece[0] = new Array(false, false, false, false);
					piece[1] = new Array(false, true, true, false);
					piece[2] = new Array(true, true, false, false);
					piece[3] = new Array(false, false, false, false);
					break;
				case 6:
					piece[0] = new Array(false, true, false, false);
					piece[1] = new Array(true, true, true, false);
					piece[2] = new Array(false, false, false, false);
					piece[3] = new Array(false, false, false, false);
					break;
			}

			while (orientation > 0) {
				piece = rotate(piece);
				orientation--;
			}

			return piece;
		}

		function newpiece() {
			// temp.
			cur_x = 5;
			cur_y = 0;

			current = generate_piece(next_id, next_o);
			currentcolor = next_id;
			generate_random();

			// Remonte un peu l'objet si commence par du vide.
			for (var l = 0; l < 4; l++) {
				var vide = true;
				for (var c = 0; c < 4; c++) {
					vide = vide && !current[l][c];
				}
				if (vide) {
					cur_y--;
				} else {
					break;
				}
			}
			
			actualise_piece();
		}

		function actualise_piece() {
			currentobj = document.createElement("div");
			document.getElementById("airejeu").appendChild(currentobj);
			currentobj.className = 'piece';
			currentobj.style.top = cur_y * 20;
			currentobj.style.left = cur_x * 20;
			for (var l = 0; l < 4; l++) {
				for (var c = 0; c < 4; c++) {
					if (current[l][c]) {
						bloc = document.createElement("div");
						currentobj.appendChild(bloc);
						bloc.className = 'bloc';
						bloc.style.top = l * 20 + 1;
						bloc.style.left = c * 20 + 1;
						bloc.style.background = convert(currentcolor);
					}
				}
			}
		}

		function convert(color) {
			switch (color) {
				case 0: return "#0000FF";
				case 1: return "#FFFF00";
				case 2: return "#00FF00";
				case 3: return "#800080";
				case 4: return "#FF0000";
				case 5: return "#0000FF";
				case 6: return "#FFFF00";
			}
		}

		function actualise_grille() {
			airejeu = document.getElementById("airejeu");
			while (airejeu.childNodes.length > 0) {
				airejeu.removeChild(airejeu.childNodes[0]);
			}

			// On reconstruit
			for (var l = 0; l < 22; l++) {
				for (var c = 0; c < 12; c++) {
					if (gamearea[l][c] >= 0) {
						bloc = document.createElement("div");
						document.getElementById("airejeu").appendChild(bloc);
						bloc.className = 'bloc';
						bloc.style.top = l * 20 + 1;
						bloc.style.left = c * 20 + 1;
						bloc.style.background = convert(gamearea[l][c]);
					}
				}
			}
		}

		function checktetris() {
			for (var l = 0; l < 22; l++) {
				var tetris = true;
				for (var c = 0; c < 12; c++) {
					tetris = tetris && (gamearea[l][c] >= 0);
				}
				if (tetris) {
					for (var ll = l; ll > 0; ll--) {
						for (var c = 0; c < 12; c++) {
							gamearea[ll][c] = gamearea[ll-1][c];
						}
					}
					for (var c = 0; c < 12; c++) {
						gamearea[0][c] = -1;
					}
				}
			}
			actualise_grille();
		}

		function print_debug() {
				// Debug !
				document.getElementById("debug").innerHTML = "";
				for (var l = 0; l < 22; l++) {
					for (var c = 0; c < 12; c++) {
						if (l >= cur_y && l < cur_y + 4 &&
							 c >= cur_x && c < cur_x + 4 &&
							  	current[l-cur_y][c-cur_x]) {
							document.getElementById("debug").innerHTML += "#";
						} else {
							if (gamearea[l][c] > 0)
								document.getElementById("debug").innerHTML += " ";
							document.getElementById("debug").innerHTML += gamearea[l][c];
						}
					}
					document.getElementById("debug").innerHTML += "<br/>";
				}
		}

		function step() {
			//print_debug();
		
			var stop = false;
			for (var l = 0; l < 4 && !stop; l++) {
				for (var c = 0; c < 4 && !stop; c++) {
					if (current[l][c]) {
						if (l+cur_y+1 >= 22 || gamearea[l+cur_y+1][c+cur_x] >= 0) {
							stop = true;
						}
					}
				}
			}
			if (!stop) {
				cur_y++;
				currentobj.style.top = cur_y * 20;
			} else {
				if (cur_y <= 0) {
					perdu = true;
				}
				// On dépose les pièces
				for (var l = 0; l < 4; l++) {
					for (var c = 0; c < 4; c++) {
						if (current[l][c]) {
							gamearea[l+cur_y][c+cur_x] = currentcolor;
							bloc = document.createElement("div");
							document.getElementById("airejeu").appendChild(bloc);
							bloc.className = 'bloc';
							bloc.style.top = (cur_y + l) * 20 + 1;
							bloc.style.left = (cur_x + c) * 20 + 1;
							bloc.style.background = convert(currentcolor);
						}
					}
				}
				piecedepose = true;
				checktetris();
				newpiece();
			}
			if (!perdu) {
				clearTimeout(montimer);
				montimer = window.setTimeout("step()", 1000);
			} else {
				window.alert("Perdu !");
			}
		}


		function touche(e) {
			if (perdu) return;
	//		print_debug();
			if (e.keyCode == 38 || e.keyCode == 56) {
				piece = rotate(current);
				// verifie si new ok.
				var ok = true;

				for (var l = 0; l < 4 && ok; l++) {
					for (var c = 0; c < 4 && ok; c++) {
						if (piece[l][c]) {
							ok = (cur_x + c) >= 0 && (cur_x + c) < 12 && (cur_y + l) < 22 && gamearea[cur_y+l][cur_x+c] < 0;
						}
					}
				}


				if (ok) {
					current = piece;
					document.getElementById("airejeu").removeChild(currentobj);
					actualise_piece();
				}
			}
			if (e.keyCode == 39 || e.keyCode == 54) {
				var ok = true;
				for (var l = 0; l < 4 && ok; l++) {
					for (var c = 0; c < 4 && ok; c++) {
						if (current[l][c]) {
							if (c+cur_x+1 >= 12 || gamearea[l+cur_y][c+cur_x+1] >= 0) {
								ok = false;
							}
						}
					}
				}
				if (ok) {
					cur_x++;
				}
			}
			if (e.keyCode == 37 || e.keyCode == 52) {
				var ok = true;
				for (var l = 0; l < 4 && ok; l++) {
					for (var c = 0; c < 4 && ok; c++) {
						if (current[l][c]) {
							if (c+cur_x-1 < 0 || gamearea[l+cur_y][c+cur_x-1] >= 0) {
								ok = false;
							}
						}
					}
				}
				if (ok) {
					cur_x--;
				}

			}
			if (e.keyCode == 40 || e.keyCode == 50) {
				clearTimeout(montimer);
				step();
			}

			if (e.charCode == 32) {
				piecedepose = false;
				while (!piecedepose) {
					step();
				}
			}

			currentobj.style.left = cur_x * 20;
		}

		-->
		</script>
	</head>
	<body onload="init()" onkeypress="touche(event)">
		<div id="airejeu"></div>
		<div id="nextpiece"></div>
		<div id="debug" style="margin-left: 400px"></div>
	</body>
</html>
